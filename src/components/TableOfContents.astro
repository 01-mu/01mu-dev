---
const {
  headings = [],
  levels = [2, 3],
  title = "On this page",
} = Astro.props;

const visibleHeadings = headings.filter((heading) =>
  levels.includes(heading.depth),
);
---

{visibleHeadings.length > 0 && (
  <nav class="toc" aria-label="Table of contents">
    <p class="toc-title">{title}</p>
    <ul class="toc-list">
      {visibleHeadings.map((heading) => (
        <li class={`toc-item depth-${heading.depth}`}>
          <a href={`#${heading.slug}`} data-toc-link={heading.slug}>
            {heading.text}
          </a>
        </li>
      ))}
    </ul>
  </nav>
)}

<script type="module">
  const initToc = () => {
    const tocContainer = document.querySelector(".toc");
    const links = Array.from(
      document.querySelectorAll("[data-toc-link]"),
    );
    const headings = links
      .map((link) => document.getElementById(link.dataset.tocLink))
      .filter(Boolean);

    if (links.length === 0 || headings.length === 0) {
      return;
    }

    let lastActiveIndex = -1;
    const pad = 48;
    const setActiveIndex = (activeIndex) => {
      links.forEach((link, index) => {
        link.classList.toggle("is-active", index === activeIndex);
        link.classList.toggle("is-past", index < activeIndex);
      });

      if (activeIndex !== lastActiveIndex) {
        const activeLink = links[activeIndex];
        if (tocContainer && activeLink) {
          const containerRect = tocContainer.getBoundingClientRect();
          const linkRect = activeLink.getBoundingClientRect();
          const topEdge = containerRect.top + pad;
          const bottomEdge = containerRect.bottom - pad;

          if (linkRect.top < topEdge) {
            tocContainer.scrollTop -= topEdge - linkRect.top;
          } else if (linkRect.bottom > bottomEdge) {
            tocContainer.scrollTop += linkRect.bottom - bottomEdge;
          }
        }
        lastActiveIndex = activeIndex;
      }
    };

    let offsets = [];
    const updateOffsets = () => {
      offsets = headings.map(
        (heading) => heading.getBoundingClientRect().top + window.scrollY,
      );
    };

    const updateActive = () => {
      const targetY = window.scrollY + window.innerHeight * 0.3;
      let activeIndex = 0;

      offsets.forEach((offset, index) => {
        if (offset <= targetY) {
          activeIndex = index;
        }
      });

      setActiveIndex(activeIndex);
    };

    let ticking = false;
    const onScroll = () => {
      if (ticking) {
        return;
      }
      ticking = true;
      window.requestAnimationFrame(() => {
        updateActive();
        ticking = false;
      });
    };

    window.addEventListener("scroll", onScroll, { passive: true });
    window.addEventListener("resize", () => {
      updateOffsets();
      onScroll();
    });
    updateOffsets();
    updateActive();
  };

  initToc();
</script>
